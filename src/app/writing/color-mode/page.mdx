import { ColorModeCover } from "./ColorModeCover";
import { ColorModeToggleDemo } from "./ColorModeToggleDemo";
import { ContrastPicker } from "./ContrastPicker";

export const metadata = {
  date: "2025-10-15",
  description:
    "How I implemented an animated dark mode using CSS @property and a fancy toggle."
};

<ColorModeCover />

# Animated Dark Mode Transition with Modern CSS

For my website, I wanted to have a smooth transition when switching between light and dark modes. You can check out the final result in this small demo:

<ColorModeToggleDemo showToggle isAnimated>
  Click the button to toggle modes:
</ColorModeToggleDemo>

You can also see the effect by clicking the small icon in the top-left corner; colors should quickly cross-fade, while the button itself does a little spherical animation.

In this post I will explain how I implemented this using CSS & SVG.

<TableOfContents />

## Setup - Defining the Color Palette

I will be focusing on the CSS implementation of the effect. The logic itself in React is mostly based on Josh Comeau's [Quest for the Perfect Dark Mode](https://www.joshwcomeau.com/react/dark-mode/) with some extra help from [Matt Stobbs's post](https://www.mattstobbs.com/elderjs-dark-mode/). You are welcome to take a look at the source code of this site as well, if interested.

The basic idea is simple - we define a color palette using CSS variables (a.k.a. [custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascading_variables/Using_CSS_custom_properties)) and then override the colors with their dark versions under the `.dark` class selector:

```css
:root {
  --foreground-color: #ddd;
  --background-color: #111;

  color: var(--foreground-color);
  background-color: var(--background-color);
}

:root.dark {
  --foreground-color: #111;
  --background-color: #ddd;
}
```

We can then toggle this class on the root element using Javascript when the user clicks the toggle button :

```js
function toggleDarkMode() {
  const root = document.documentElement;
  const isDark = root.classList.contains("dark");

  if (isDark) {
    root.classList.remove("dark");
  } else {
    root.classList.add("dark");
  }
}
```

<ColorModeToggleDemo isAnimated={false}>
  Click to toggle dark class:
</ColorModeToggleDemo>

When the `dark` class is added or removed, the browser automatically updates all the elements that use the properties we defined! In this case, the text and background colors change.

## Animating the Transition

To get a nice animation between the color modes, we can declare a CSS transition for any property that uses our colors - in this case, `color` and `background-color`. In order to keep the timing consistent, I like to define and reuse a `--transition-defaults` variable:

```css
body {
  /* ... */
  --transition-defaults: 400ms ease-out;

  transition:
    background-color var(--transition-defaults),
    color var(--transition-defaults);
}
```

<ColorModeToggleDemo isAnimated={true}>
  Click to toggle dark class:
</ColorModeToggleDemo>

However, what if we want to add another transition to our button, say make it grow on hover?

```css
.button {
  transform: scale(1);
  transition: transform var(--transition-defaults);
}

.button:hover {
  transform: scale(1.1);
  transition: transform var(--transition-defaults);
}
```

<ColorModeToggleDemo
  isAnimated={true}
  isGrowing={true}
  style={{
    transition:
      "background-color var(--transition-timing), color var(--transition-timing)",
    color: "var(--foreground-color-raw)"
  }}
>
  Click to toggle dark class:
</ColorModeToggleDemo>

Try clicking the button again - the scale transitions nicely but colors change immediately! This is because the button's `transition: transform` declaration overrides the `transition: color` we had on our `body`.

We can solve it by defining `transition: transform, color` but it can become cumbersome very quickly and easy to forget. If we miss a single element it suddenly sticks out unnaturally when switching modes. Thankfully, there is a new CSS _at-rule_ that makes this much simpler.

## Using @property

> The `@property` CSS at-rule is part of the CSS Houdini set of APIs. It allows developers to explicitly define CSS custom properties, allowing for property type checking and constraining, setting default values, and defining whether a custom property can inherit values or not.

[@property on MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@property)

Crucially for our use, it allows us to _transform_ custom css properties! we define our colors inside `@property` blocks with `syntax: "<color>"`:

```css
@property --foreground-color {
  syntax: "<color>";
  inherits: true;
  initial-value: #ddd;
}

@property --background-color {
  syntax: "<color>";
  inherits: true;
  initial-value: #111;
}

body {
  --foreground-color: #ddd;
  --background-color: #111;

  color: var(--foreground-color);
  background-color: var(--background-color);
}

body.dark {
  --foreground-color: #111;
  --background-color: #ddd;

  transition:
    --foreground-color var(--transition-defaults),
    --background-color var(--transition-defaults);
}
```

## Using Transparency

By using transparent colors, we can build up the UI without fiddling with more color definitions - just foreground and background. To achieve this, I like to define the color RGB values in a separate variable, then reuse it inside `rgba()` color definitions:

This works especially for monochromatic color schemes.

## Creating the Fancy Toggle

different toggles:

- Sun / moon
- Half circle
- Apple thing

The nice thing is that it sort of behaves like a toggle - with the white part moving from side to side
while the icon itself stays the same shape in negative

The idea is to have 2 halves
There is a hidden circle in the middle with scaleX(0), with each half being one color
On animating, the hidden inner circle is animated to a scale of scaleX(1), then the two halves are flipped, then the scale is animated back to scaleX(0)

<ColorModeToggleDemo showToggle isAnimated />
_Demo embed_ https://codepen.io/shamir/pen/YGbbNX

### The Setup

HTML button element

```html
<button class="ThemeToggle">
  <span class="ThemeToggle__half ThemeToggle__half--left"></span>
  <span class="ThemeToggle__half ThemeToggle__half--right"></span>
</button>
```

CSS

```css
.ThemeToggle {
  --size: 60px;
  --border-width: 2px;
}
```

### Animating the toggle

The animation is split into 4 parts:

1. The initial state
2. The first half of the animation
3. The second half of the animation
4. The final state

## Final touches - favicon

dynamic favicon

## Naming - Theme, Scheme or Mode?

First things first - how do I name this feature?

I believe naming things is very important, especially in code. When writing this post I decided to get to the bottom of this!

I found 3 commonly used terms - **Color Theme**, **Color Scheme** and **Color Mode**, as well as some less common options such as _Brightness_ in Flutter or _UIUserInterfaceStyle_ (ahem, UIKit). I'll focus on the 3 prevalent options:

### Color Theme

A theme can be defined as _A recurring idea; a motif_ - in the context of UI design, it is [usually](<https://en.wikipedia.org/wiki/Theme_(computing)>) refers to a "package" that contains fonts, colors, shapes and more.
I feel that colors are _part_ of a UI theme, so the term "Color Theme" doesn't feel right to me.

VS Code:
`"workbench.colorTheme": "Dark+ (default dark)"`

Material UI (MUI)
“palette mode” (light/dark) e.g. `theme.palette.mode='dark'`

Jetpack Compose (Android)
“light theme” / “dark theme” (Material 3 ColorScheme); use `isSystemInDarkTheme()` to pick light/dark

### Color Scheme

[Color Scheme](https://en.wikipedia.org/wiki/Color_scheme)

A color scheme, from my understanding, is synonymous with a "color palette" - a set of colors designed to work well together. In this case, you could consider the light and dark colors to be a "scheme", or part of the overall "color scheme"
Scheme - _An orderly combination of related parts._

Rooted in design theory (“monochromatic scheme”, “analogous scheme”).

CSS uses `prefers-color-scheme: light | dark`

iOS / SwiftUI:
`ColorScheme.light`, `ColorScheme.dark`

### Color Mode

[Mode (User Interface)](<https://en.wikipedia.org/wiki/Mode_(user_interface)>)

Meaning: Almost always refers to a binary or categorical setting (e.g., “Light mode” vs “Dark mode”). Less about aesthetics, more about state or preference.

Android:
Uses `UiModeManager` (`MODE_NIGHT_YES`, `MODE_NIGHT_NO`) and XML attribute android:theme.

Material UI (MUI):
`palette.mode = 'light' | 'dark'`

Chakra UI:
`colorMode = 'light' | 'dark'` and `useColorMode()` hook.

Tailwind CSS:
Uses `dark:` prefix (no explicit variable).
Config has `darkMode: 'media' | 'class'`.
