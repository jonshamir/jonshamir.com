import { ColorModeCover } from "./ColorModeCover";
import { ColorModeToggleDemo } from "./ColorModeToggleDemo";
import { ContrastPicker } from "./ContrastPicker";

export const metadata = {
  date: "2025-12-16",
  description:
    "How I implemented an animated dark mode using CSS @property and a fancy toggle."
};

<ColorModeCover />

# Animated Dark Mode Transition with Modern CSS

## Designing and implementing a modern dark mode feature

In this post I will explain how to implement a smooth transition between light and dark mode, using CSS `@property`. You can see the effect by clicking the small icon in the top-right corner, or in this small demo sandbox:

<ColorModeToggleDemo showToggle isAnimated>
  Click the button to toggle modes:
</ColorModeToggleDemo>

I will be focusing on the CSS implementation of the effect. The logic itself in React is mostly based on Josh Comeau's [Quest for the Perfect Dark Mode](https://www.joshwcomeau.com/react/dark-mode/) with some extra help from [Matt Stobbs's post](https://www.mattstobbs.com/elderjs-dark-mode/). You are also welcome to take a look at the source code of this site.

<TableOfContents />

## Setup - Defining the Color Palette & Toggle

The basic idea is simple - we define a color palette using CSS variables (a.k.a. [custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascading_variables/Using_CSS_custom_properties)), then override their values with dark colors under the `.dark` class selector:

<CodeDemo demo={<ColorModeToggleDemo isAnimated={false}>
  Click to toggle dark class:
</ColorModeToggleDemo>}>

```css
:root {
  --foreground-color: #111;
  --background-color: #ddd;

  color: var(--foreground-color);
  background-color: var(--background-color);
}

:root.dark {
  --foreground-color: #ddd;
  --background-color: #111;
}
```

</CodeDemo>

We'll also add a simple button to switch the color mode - when a user clicks the button, we toggle the `dark` class on the root element using JavaScript:

```js
// This is called when the button is clicked
function toggleDarkMode() {
  const root = document.documentElement;
  const isDark = root.classList.contains("dark");

  if (isDark) {
    root.classList.remove("dark");
  } else {
    root.classList.add("dark");
  }
}
```

With the magic of CSS variables, the browser automatically updates all elements that use the colors we defined! In this case, the text and background colors change, as well as the button itself.

## Animating the Transition

To get a nice animation between the modes, we can declare a CSS `transition` for every property that uses our colors - in this case, `color` and `background-color`. In order to keep the timing consistent, I like to define and reuse a `--transition-timing` variable:

```css
:root {
  --transition-timing: 400ms ease-out;

  transition:
    background-color var(--transition-timing),
    color var(--transition-timing);
}
```

<ColorModeToggleDemo isAnimated={true}>
  Click to toggle dark class:
</ColorModeToggleDemo>

We did it - The text and background colors cross-fade nicely!

But alas - our button still flashes immediately to the new colors. This is because we added some nice hover & active effects on the button which accidentally override the `transition` we declared on our `:root`:

```css
button {
  /* This overrides transition of color & background-color :( */
  transition:
    opacity 150ms ease-out,
    transform 150ms ease-out;
}

button:hover {
  opacity: 1;
}

button:active {
  transform: scale(0.95);
}
```

We can solve it naively by defining a `transition` of all the properties together:

```css
button {
  transition:
    opacity 150ms ease-out,
    transform 150ms ease-out,
    background-color var(--transition-timing),
    color var(--transition-timing);
}
```

However, this quickly becomes cumbersome and easy to forget. If we miss a single element it suddenly sticks out unnaturally when switching modes.

_Find the offending element_

Thankfully, there is a new CSS _at-rule_ that makes things much simpler.

## Using @property

What if instead of transitioning each CSS property that uses a colors, we could transition the _color variables themselves_? This is now possible thanks to `@property` rules!

> The `@property` CSS at-rule is part of the CSS Houdini set of APIs. It allows developers to explicitly define CSS custom properties, allowing for property type checking and constraining, setting default values, and defining whether a custom property can inherit values or not.

[@property on MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@property)

Crucially for us, it allows us to _transition_ the css variables themselves! we define our colors inside `@property` blocks with `syntax: "<color>"`:

```css
property --foreground-color {
  syntax: "<color>";
  inherits: true;
  initial-value: #111;
}

property --background-color {
  syntax: "<color>";
  inherits: true;
  initial-value: #ddd;
}
```

We then define the colors as we did before, keeping backwards compatibility. Them we declare a transition on the custom properties themselves rather than on the specific properties:

```css
:root {
  --foreground-color: #111;
  --background-color: #ddd;

  color: var(--foreground-color);
  background-color: var(--background-color);

  transition:
    --foreground-color var(--transition-timing),
    --background-color var(--transition-timing);
}

:root.dark {
  --foreground-color: #ddd;
  --background-color: #111;
}
```

Finally, the result is a smooth animation wherever the variable is used, without having to think twice when overriding `transition`:

<ColorModeToggleDemo isAnimated useAtProp>
  Click to toggle dark class:
</ColorModeToggleDemo>

## System preferences and switching behavior

Modern CSS allows us to query the users's preferred color scheme and use that to color our site.

Some apps allow to pick "System" color theme as an option - however, I believe in sensible defaults, rather than let the user pick the color theme each time, the site should always use the preferred scheme. If the user wants to switch the theme using the toggle on my site, without changing the OS settings, I feel we can assume it is temporary fix for a particularly light or dark environment.

## Creating the Fancy Toggle

In general, the most commonly used icons to represent color modes are sum / moon or the half circle "contrast" thingy.

There are multiple examples online of cool sun-to-moon animations:

However, I wanted something a bit different:

<ColorModeToggleDemo showToggle isAnimated />

The nice thing is that it sort of behaves like a "classic" switch UI - with the white part moving from side to side while the icon itself stays the same shape.

### The Setup

The idea is to have 2 halves
There is a hidden circle in the middle with scaleX(0), with each half being one color
On animating, the hidden inner circle is animated to a scale of scaleX(1), then the two halves are flipped, then the scale is animated back to scaleX(0)

_Demo embed_ https://codepen.io/shamir/pen/YGbbNX

### The Setup

I draw the icon using SVG, with a stroked `<circle>` creating the outline, and 3 copies of a semicircle drawn using `<path>`:

```html
<svg width="48" height="48" viewBox="0 0 24 24">
  <circle
    cx="12"
    cy="12"
    r="8"
    stroke="currentColor"
    strokeWidth="1.5"
    fill="none"
  />
  <path className="RightSideBG" d="M 12 5 A 7 7 0 0 1 12 19" />
  <path className="LeftSide" d="M 12 5 A 7 7 0 0 1 12 19" />
  <path className="RightSide" d="M 12 5 A 7 7 0 0 1 12 19" />
</svg>
```

CSS

```css
.RightSideBG {
  fill: currentColor;
  transform-origin: center;
  transform: scale(1.1); /* to hide the seam */
}

.LeftSide,
.RightSide {
  fill: rgb(221, 221, 221);
  transform-origin: center;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-duration: var(--duration);
}

.LeftSide {
  animation-name: rotateLeft;
  animation-direction: normal;
}

.RightSide {
  animation-name: rotateRight;
  animation-direction: normal;
}

.dark {
  .LeftSide {
    animation-name: rotateLeftDark;
  }

  .RightSide {
    animation-name: rotateRightDark;
  }
}
```

### Animating the toggle

The animation is split into 4 parts:

1. The initial state
2. The first half of the animation
3. The second half of the animation
4. The final state

## Footnote: Naming - Theme, Scheme or Mode?

First things first - how do I name this feature?

I believe naming things is very important, especially in code. When writing this post I decided to get to the bottom of this!

I found 3 commonly used terms - **Color Theme**, **Color Scheme** and **Color Mode**, as well as some less common options such as _Brightness_ in Flutter or _UIUserInterfaceStyle_ (ahem, UIKit). I'll focus on the 3 prevalent options:

### Color Theme

A theme can be defined as _A recurring idea; a motif_ - in the context of UI design, it is [usually](<https://en.wikipedia.org/wiki/Theme_(computing)>) refers to a "package" that contains fonts, colors, shapes and more.
I feel that colors are _part_ of a UI theme, so the term "Color Theme" doesn't feel right to me.

VS Code:
`"workbench.colorTheme": "Dark+ (default dark)"`

Material UI (MUI)
“palette mode” (light/dark) e.g. `theme.palette.mode='dark'`

Jetpack Compose (Android)
“light theme” / “dark theme” (Material 3 ColorScheme); use `isSystemInDarkTheme()` to pick light/dark

### Color Scheme

[Color Scheme](https://en.wikipedia.org/wiki/Color_scheme)

A color scheme, from my understanding, is synonymous with a "color palette" - a set of colors designed to work well together. In this case, you could consider the light and dark colors to be a "scheme", or part of the overall "color scheme"
Scheme - _An orderly combination of related parts._

Rooted in design theory (“monochromatic scheme”, “analogous scheme”).

CSS uses `prefers-color-scheme: light | dark`

iOS / SwiftUI:
`ColorScheme.light`, `ColorScheme.dark`

### Color Mode

[Mode (User Interface)](<https://en.wikipedia.org/wiki/Mode_(user_interface)>)

Meaning: Almost always refers to a binary or categorical setting (e.g., “Light mode” vs “Dark mode”). Less about aesthetics, more about state or preference.

Android:
Uses `UiModeManager` (`MODE_NIGHT_YES`, `MODE_NIGHT_NO`) and XML attribute android:theme.

Material UI (MUI):
`palette.mode = 'light' | 'dark'`

Chakra UI:
`colorMode = 'light' | 'dark'` and `useColorMode()` hook.

Tailwind CSS:
Uses `dark:` prefix (no explicit variable).
Config has `darkMode: 'media' | 'class'`.
