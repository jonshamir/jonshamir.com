import { ColorModeCover } from "./ColorModeCover";
import { ColorModeToggleDemo } from "./ColorModeToggleDemo";
import { ContrastPicker } from "./ContrastPicker";

export const metadata = {
  date: "2026-03-01",
  description:
    "How I implemented an animated dark mode using CSS @property and a fancy toggle."
};

<ColorModeCover />

# Animated Dark Mode Transition with Modern CSS

Switching between dark and light modes can be pretty jarring - a wrong click can nearly blind you in the middle of the night. While we can't prevent accidents, we can give users' eyes a bit more time to adjust by animating the transition:

<ColorModeToggleDemo isAnimated useAtProp>
  Click the button to toggle modes:
</ColorModeToggleDemo>

In this post I will explore several ways to implement the effect with modern CSS. You can also see the effect on my site by clicking the small icon in the top-right corner.

I will be focusing on the CSS implementation of the effect. The logic I used for my this (React-based) website is mostly based on Josh Comeau's [Quest for the Perfect Dark Mode](https://www.joshwcomeau.com/react/dark-mode/) with some help from [Matt Stobbs's post](https://www.mattstobbs.com/elderjs-dark-mode/).

<TableOfContents />

## Defining the color palette

The basic idea is simple - we define a color palette using CSS variables (a.k.a. [custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascading_variables/Using_CSS_custom_properties)), then override their values with dark colors under the `.dark` class selector:

```css
:root {
  --foreground-color: #111;
  --background-color: #ddd;

  color: var(--foreground-color);
  background-color: var(--background-color);
}

:root.dark {
  --foreground-color: #ddd;
  --background-color: #111;
}
```

We can add a button to switch the color mode by toggling the `dark` class on the container element. Whenever the class changes, the browser automatically updates all elements that use the colors we defined! Our basic dark mode feature is now working.

<CodeDemo demo={<ColorModeToggleDemo isAnimated={false}>
  Click to toggle dark class:
</ColorModeToggleDemo>}>

```js
// Called when the button is clicked
function toggleDarkMode() {
  const root = document.documentElement;
  const isDark = root.classList.contains("dark");

  if (isDark) {
    root.classList.remove("dark");
  } else {
    root.classList.add("dark");
  }
}
```

</CodeDemo>

## Animating the transition

My first approach was to use CSS transitions to animate the switch. Transitions tell the browser to animate a property whenever its value changes. In our case, we can declare a `transition` for every property that uses the theme colors - `color` and `background-color`:

<CodeDemo demo={<ColorModeToggleDemo isAnimated={true}>
  Click to toggle dark class:
</ColorModeToggleDemo>}>

```css
:root {
  transition:
    background-color 400ms ease,
    color 400ms ease;
}
```

</CodeDemo>

We did it - The text and background colors cross-fade nicely!

But alas - our button still flashes immediately to the new colors. This is because we have some nice hover & active effects on the button which accidentally override the `transition` we declared on our `:root`:

```css
button {
  /* This overrides the :root transition  :( */
  transition:
    opacity 150ms ease,
    transform 150ms ease;
}

button:hover {
  opacity: 1;
}

button:active {
  transform: scale(0.95);
}
```

We can solve it naively by defining a `transition` of all the properties together:

```css
button {
  transition:
    opacity 150ms ease,
    transform 150ms ease,
    background-color 400ms ease,
    color 400ms ease;
}
```

This will work, but it quickly becomes cumbersome and easy to forget.
If we want to use the colors on another property, like `border-color` - we have to add even more transition declaration - not exactly maintainable.
Even worse, if we accidentally miss a single element it suddenly sticks out unnaturally when switching modes.

Thankfully, there is a new CSS _at-rule_ that makes things much simpler.

## Using @property

What if instead of transitioning each CSS property that uses a color, we could transition the _color variables themselves_? This is now possible thanks to `@property` rules:

> The `@property` CSS at-rule is part of the CSS Houdini set of APIs. It allows developers to explicitly define CSS custom properties, allowing for property type checking and constraining, setting default values, and defining whether a custom property can inherit values or not.

[@property on MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@property)

In addition to our original variable definitions, we can tell the browser the _type_ of the variables by using `@property` blocks with `syntax: "<color>"`:

```css
property --foreground-color {
  syntax: "<color>";
  inherits: true;
  initial-value: #111;
}

property --background-color {
  syntax: "<color>";
  inherits: true;
  initial-value: #ddd;
}
```

We can now declare a `transition` on our variables, and the browser will know to treat their values as colors. Whenever the variables change, we get a smooth color interpolation with minimal boilerplate and without having to think twice about overriding transitions:

<CodeDemo demo={<ColorModeToggleDemo isAnimated useAtProp>
  Click to toggle dark class:
</ColorModeToggleDemo>}>

```css
:root {
  --foreground-color: #111;
  --background-color: #ddd;

  color: var(--foreground-color);
  background-color: var(--background-color);

  /* This is the magic */
  transition:
    --foreground-color 400ms ease,
    --background-color 400ms ease;
}

:root.dark {
  --foreground-color: #ddd;
  --background-color: #111;
}
```

</CodeDemo>

## Browser support

What's nice about this technique is that is it a _progressive enhancement_ - older browsers will just see the color change without the animation, ensuring the website remains accessible.

On [caniuse.com](https://caniuse.com/?search=%40property) you can see that the virtually all modern browsers support `@property` declarations (~94
% of global users at the time of writing).

## Using the View Transition API

There's another approach to animating a color mode switch — instead of transitioning individual CSS properties, we can use the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API) to capture before/after snapshots of the page and crossfade between them.

The idea is simple: call `document.startViewTransition()` with a callback that updates the DOM. The browser takes a screenshot of the current state, runs the callback, then smoothly crossfades from the old screenshot to the new state:

<CodeDemo demo={<ColorModeToggleDemo useViewTransition>
  Click to toggle with view transition:
</ColorModeToggleDemo>}>

```js
function toggleDarkMode() {
  // Fallback for unsupported browsers
  if (!document.startViewTransition) {
    root.classList.toggle("dark");
    return;
  }

  document.startViewTransition(() => {
    root.classList.toggle("dark");
  });
}
```

</CodeDemo>

That's all there is to it — the browser handles the crossfade animation automatically. When using view transitions, the CSS transitions from the `@property` approach should be disabled — otherwise you'd get a double animation (the crossfade _and_ the color interpolation happening simultaneously).

**Which approach should you use?** The `@property` technique is simpler, more widely supported (~94% of users), and gives you a true color interpolation. View transitions are more flexible — you can swap the default crossfade for clip-path reveals, directional wipes, or other effects — but have less browser support (Chrome/Edge 111+, Safari 18+, no Firefox yet, ~75% of users). For a great example of a circular clip-path reveal effect using view transitions, check out [Akash Hamirwasia's post](https://akashhamirwasia.com/blog/full-page-theme-toggle-animation-with-view-transitions-api/).

## Wrapping Up

The `@property` rule is one of those CSS features that feels like it should have always existed. Instead of chasing down every element that needs a color transition, you define the transition once at the variable level and everything just works. It's less code, fewer edge cases, and one less thing to remember when adding new components.
This is just one example, but the implications go beyond dark mode — any time you're animating values stored in custom properties (gradients, spacing, angles), `@property` opens the door.

## Footnote: Theme, Scheme or Mode?

I believe naming things is very important, especially in code. When writing this post I decided to get to the bottom of this and decide for myself what would be the best name for this feature!

I found 3 commonly used terms - **Color Theme**, **Color Scheme** and **Color Mode**, as well as some less common options such as _Brightness_ in Flutter or _UIUserInterfaceStyle_ (ahem, UIKit). I'll focus on the 3 prevalent options:

<table>
  <thead>
    <tr>
      <th></th>
      <th>Definition</th>
      <th>Scope</th>
      <th>Rooted in</th>
      <th>Used by</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <strong>Color Theme</strong>
      </td>
      <td>A recurring motif; a "package" of fonts, colors, shapes, etc.</td>
      <td>
        Broad — colors are just <em>part</em> of a theme
      </td>
      <td>Software/UI conventions</td>
      <td>
        VS Code (<code>workbench.colorTheme</code>), Jetpack Compose (
        <code>isSystemInDarkTheme()</code>)
      </td>
    </tr>
    <tr>
      <td>
        <strong>Color Scheme</strong>
      </td>
      <td>
        An orderly combination of related colors; synonymous with "color
        palette"
      </td>
      <td>Medium — a set of colors designed to work together</td>
      <td>Design theory ("monochromatic scheme", "analogous scheme")</td>
      <td>
        CSS (<code>prefers-color-scheme</code>), SwiftUI (
        <code>ColorScheme.light</code>)
      </td>
    </tr>
    <tr>
      <td>
        <strong>Color Mode</strong>
      </td>
      <td>
        A binary/categorical setting — less about aesthetics, more about state
      </td>
      <td>Narrow — specifically light vs. dark</td>
      <td>User interface state management</td>
      <td>
        Android (<code>UiModeManager</code>), MUI (<code>palette.mode</code>),
        Chakra UI (<code>useColorMode()</code>)
      </td>
    </tr>
  </tbody>
</table>

### Color Theme

A theme can be defined as _A recurring idea; a motif_ - in the context of UI design, it is [usually](<https://en.wikipedia.org/wiki/Theme_(computing)>) refers to a "package" that contains fonts, colors, shapes and more.
I feel that colors are _part_ of a UI theme, so the term "Color Theme" doesn't feel right to me.

VS Code:
`"workbench.colorTheme": "Dark+ (default dark)"`

Material UI (MUI)
“palette mode” (light/dark) e.g. `theme.palette.mode='dark'`

Jetpack Compose (Android)
“light theme” / “dark theme” (Material 3 ColorScheme); use `isSystemInDarkTheme()` to pick light/dark

### Color Scheme

[Color Scheme](https://en.wikipedia.org/wiki/Color_scheme)

A color scheme, from my understanding, is synonymous with a "color palette" - a set of colors designed to work well together. In this case, you could consider the light and dark colors to be a "scheme", or part of the overall "color scheme"
Scheme - _An orderly combination of related parts._

Rooted in design theory (“monochromatic scheme”, “analogous scheme”).

CSS uses `prefers-color-scheme: light | dark`

iOS / SwiftUI:
`ColorScheme.light`, `ColorScheme.dark`

### Color Mode

[Mode (User Interface)](<https://en.wikipedia.org/wiki/Mode_(user_interface)>)

Meaning: Almost always refers to a binary or categorical setting (e.g., “Light mode” vs “Dark mode”). Less about aesthetics, more about state or preference.

Android:
Uses `UiModeManager` (`MODE_NIGHT_YES`, `MODE_NIGHT_NO`) and XML attribute android:theme.

Material UI (MUI):
`palette.mode = 'light' | 'dark'`

Chakra UI:
`colorMode = 'light' | 'dark'` and `useColorMode()` hook.

Tailwind CSS:
Uses `dark:` prefix (no explicit variable).
Config has `darkMode: 'media' | 'class'`.
